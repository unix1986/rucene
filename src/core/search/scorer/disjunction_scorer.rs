// Copyright 2019 Zhizhesihai (Beijing) Technology Limited.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

use core::search::scorer::Scorer;
use core::search::{DocIterator, NO_MORE_DOCS};
use core::util::DocId;

use error::Result;
use std::f32;

/// A Scorer for OR like queries, counterpart of `ConjunctionScorer`.
pub struct DisjunctionSumScorer<T: Scorer> {
    sub_scorers: Vec<T>,
    curr_doc: DocId,
    cost: usize,
}

impl<T: Scorer> DisjunctionSumScorer<T> {
    pub fn new(children: Vec<T>, _needs_scores: bool) -> DisjunctionSumScorer<T> {
        assert!(children.len() > 1);

        let cost = children.iter().map(|w| w.cost()).sum();
        let mut curr_doc = NO_MORE_DOCS;
        for s in children.iter() {
            curr_doc = curr_doc.min(s.doc_id());
        }

        DisjunctionSumScorer {
            sub_scorers: children,
            curr_doc,
            cost,
        }
    }
}

impl<T: Scorer> Scorer for DisjunctionSumScorer<T> {
    fn score(&mut self) -> Result<f32> {
        let mut score: f32 = 0.0f32;

        let doc_id = self.doc_id();
        for s in self.sub_scorers.iter_mut() {
            if s.doc_id() == doc_id {
                let sub_score = s.score()?;
                score += sub_score;
            }
        }

        Ok(score)
    }
}

impl<T: Scorer> DocIterator for DisjunctionSumScorer<T> {
    fn doc_id(&self) -> DocId {
        self.curr_doc
    }

    fn next(&mut self) -> Result<DocId> {
        self.approximate_next()
    }

    fn advance(&mut self, target: DocId) -> Result<DocId> {
        self.approximate_advance(target)
    }

    fn cost(&self) -> usize {
        self.cost
    }

    fn matches(&mut self) -> Result<bool> {
        Ok(true)
    }

    fn match_cost(&self) -> f32 {
        0f32
    }

    fn approximate_next(&mut self) -> Result<DocId> {
        let curr_doc = self.doc_id();
        let mut min_doc = NO_MORE_DOCS;
        for s in self.sub_scorers.iter_mut() {
            if s.doc_id() == curr_doc {
                s.approximate_next()?;
            }

            min_doc = min_doc.min(s.doc_id());
        }

        self.curr_doc = min_doc;
        Ok(self.doc_id())
    }

    fn approximate_advance(&mut self, target: DocId) -> Result<DocId> {
        let mut min_doc = NO_MORE_DOCS;
        for s in self.sub_scorers.iter_mut() {
            if s.doc_id() < target {
                s.approximate_advance(target)?;
            }

            min_doc = min_doc.min(s.doc_id());
        }

        self.curr_doc = min_doc;
        Ok(self.doc_id())
    }
}

/// The Scorer for DisjunctionMaxQuery.  The union of all documents generated by the the subquery
/// scorers is generated in document number order.  The score for each document is the maximum of
/// the scores computed by the subquery scorers that generate that document, plus
/// tieBreakerMultiplier times the sum of the scores for the other subqueries that generate the
/// document.
pub struct DisjunctionMaxScorer<T: Scorer> {
    sub_scorers: Vec<T>,
    curr_doc: DocId,
    cost: usize,
    tie_breaker_multiplier: f32,
}

impl<T: Scorer> DisjunctionMaxScorer<T> {
    pub fn new(
        children: Vec<T>,
        tie_breaker_multiplier: f32,
        _needs_score: bool,
    ) -> DisjunctionMaxScorer<T> {
        assert!(children.len() > 1);

        let cost = children.iter().map(|w| w.cost()).sum();
        let mut curr_doc = NO_MORE_DOCS;
        for s in children.iter() {
            curr_doc = curr_doc.min(s.doc_id());
        }

        DisjunctionMaxScorer {
            sub_scorers: children,
            curr_doc,
            cost,
            tie_breaker_multiplier,
        }
    }
}

impl<T: Scorer> Scorer for DisjunctionMaxScorer<T> {
    fn score(&mut self) -> Result<f32> {
        let mut score_sum = 0.0f32;
        let mut score_max = f32::NEG_INFINITY;

        let doc_id = self.doc_id();
        for s in self.sub_scorers.iter_mut() {
            if s.doc_id() == doc_id {
                let sub_score = s.score()?;

                score_sum += sub_score;
                score_max = score_max.max(sub_score);
            }
        }

        Ok(score_max + (score_sum - score_max) * self.tie_breaker_multiplier)
    }
}

impl<T: Scorer> DocIterator for DisjunctionMaxScorer<T> {
    fn doc_id(&self) -> DocId {
        self.curr_doc
    }

    fn next(&mut self) -> Result<DocId> {
        self.approximate_next()
    }

    fn advance(&mut self, target: DocId) -> Result<DocId> {
        self.approximate_advance(target)
    }

    fn cost(&self) -> usize {
        self.cost
    }

    fn matches(&mut self) -> Result<bool> {
        Ok(true)
    }

    fn match_cost(&self) -> f32 {
        0f32
    }

    fn approximate_next(&mut self) -> Result<DocId> {
        let curr_doc = self.doc_id();
        let mut min_doc = NO_MORE_DOCS;
        for s in self.sub_scorers.iter_mut() {
            if s.doc_id() == curr_doc {
                s.approximate_next()?;
            }

            min_doc = min_doc.min(s.doc_id());
        }

        self.curr_doc = min_doc;
        Ok(self.doc_id())
    }

    fn approximate_advance(&mut self, target: DocId) -> Result<DocId> {
        let mut min_doc = NO_MORE_DOCS;
        for s in self.sub_scorers.iter_mut() {
            if s.doc_id() < target {
                s.approximate_advance(target)?;
            }

            min_doc = min_doc.min(s.doc_id());
        }

        self.curr_doc = min_doc;
        Ok(self.doc_id())
    }
}
